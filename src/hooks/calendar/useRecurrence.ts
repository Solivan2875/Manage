import { useState, useEffect, useCallback } from 'react';
import type { Event, RecurrenceRule } from '../../types/calendar';
import {
    recurrenceService,
    createRecurrencePattern,
    generateRecurringEvents,
    addRecurrenceException,
    getRecurrenceRuleString,
    validateRecurrenceRule,
    type RecurrencePattern,
    type RecurrenceException
} from '../../services/recurrenceService';

interface UseRecurrenceProps {
    events: Event[];
    onEventAdd?: (event: Event) => void;
    onEventUpdate?: (id: string, updates: Partial<Event>) => void;
    onEventDelete?: (id: string) => void;
}

export const useRecurrence = ({
    events,
    onEventAdd,
    onEventUpdate,
    onEventDelete
}: UseRecurrenceProps) => {
    const [patterns, setPatterns] = useState<RecurrencePattern[]>([]);
    const [selectedPattern, setSelectedPattern] = useState<RecurrencePattern | null>(null);
    const [isCreatingPattern, setIsCreatingPattern] = useState(false);

    // Load patterns on mount
    useEffect(() => {
        const allPatterns = recurrenceService.getAllPatterns();
        setPatterns(allPatterns);
    }, []);

    // Create a recurrence pattern for an event
    const createPattern = useCallback((event: Event, rule: RecurrenceRule) => {
        const validation = validateRecurrenceRule(rule);
        if (!validation.isValid) {
            throw new Error(validation.errors.join(', '));
        }

        const pattern = createRecurrencePattern(event, rule);
        setPatterns(prev => [...prev, pattern]);

        // Generate initial recurring events
        const startDate = new Date();
        const endDate = new Date();
        endDate.setMonth(endDate.getMonth() + 6); // Generate 6 months ahead

        const recurringEvents = generateRecurringEvents(pattern.id, startDate, endDate, event);
        recurringEvents.forEach(event => {
            if (onEventAdd) {
                onEventAdd(event);
            }
        });

        return pattern;
    }, [onEventAdd]);

    // Update a recurrence pattern
    const updatePattern = useCallback((patternId: string, updates: Partial<RecurrencePattern>) => {
        const success = recurrenceService.updatePattern(patternId, updates);
        if (success) {
            setPatterns(prev =>
                prev.map(pattern =>
                    pattern.id === patternId
                        ? { ...pattern, ...updates }
                        : pattern
                )
            );

            // Regenerate events for this pattern
            regenerateEventsForPattern(patternId);
        }
        return success;
    }, []);

    // Delete a recurrence pattern
    const deletePattern = useCallback((patternId: string) => {
        const success = recurrenceService.deletePattern(patternId);
        if (success) {
            setPatterns(prev => prev.filter(pattern => pattern.id !== patternId));

            // Remove all events generated by this pattern
            if (onEventDelete) {
                events
                    .filter(event =>
                        event.recurrence?.id === patternId
                    )
                    .forEach(event => {
                        onEventDelete(event.id);
                    });
            }
        }
        return success;
    }, [events, onEventDelete]);

    // Add an exception to a recurrence pattern
    const addException = useCallback((
        patternId: string,
        originalDate: Date,
        modifiedEvent?: Event,
        isDeleted: boolean = false
    ) => {
        const success = addRecurrenceException(patternId, originalDate, modifiedEvent, isDeleted);
        if (success) {
            // Update patterns state
            setPatterns(prev =>
                prev.map(pattern => {
                    if (pattern.id === patternId) {
                        const existingException = pattern.exceptions.find(exc =>
                            exc.originalDate.getTime() === originalDate.getTime()
                        );

                        if (existingException) {
                            // Update existing exception
                            return {
                                ...pattern,
                                exceptions: pattern.exceptions.map(exc =>
                                    exc.id === existingException.id
                                        ? { ...exc, modifiedEvent, isDeleted }
                                        : exc
                                )
                            };
                        } else {
                            // Add new exception
                            const newException: RecurrenceException = {
                                id: `exception_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                originalEventId: patternId,
                                originalDate: new Date(originalDate),
                                modifiedEvent,
                                isDeleted
                            };
                            return {
                                ...pattern,
                                exceptions: [...pattern.exceptions, newException]
                            };
                        }
                    }
                    return pattern;
                })
            );

            // Update or remove the specific event
            const targetEvent = events.find(event =>
                event.recurrence?.id === patternId &&
                isSameDay(event.startDate, originalDate)
            );

            if (targetEvent) {
                if (isDeleted) {
                    if (onEventDelete) {
                        onEventDelete(targetEvent.id);
                    }
                } else if (modifiedEvent && onEventUpdate) {
                    onEventUpdate(targetEvent.id, modifiedEvent);
                }
            }
        }
        return success;
    }, [events, onEventUpdate, onEventDelete]);

    // Regenerate all events for a pattern
    const regenerateEventsForPattern = useCallback((patternId: string) => {
        const pattern = recurrenceService.getPattern(patternId);
        if (!pattern) return;

        // Remove existing events for this pattern
        const existingEvents = events.filter(event =>
            event.recurrence?.id === patternId
        );

        existingEvents.forEach(event => {
            if (onEventDelete) {
                onEventDelete(event.id);
            }
        });

        // Generate new events
        const baseEvent = events.find(event =>
            event.recurrence?.id === patternId
        );

        if (baseEvent) {
            const startDate = new Date();
            const endDate = new Date();
            endDate.setMonth(endDate.getMonth() + 6);

            const newEvents = generateRecurringEvents(patternId, startDate, endDate, baseEvent);
            newEvents.forEach(event => {
                if (onEventAdd) {
                    onEventAdd(event);
                }
            });
        }
    }, [events, onEventAdd, onEventDelete]);

    // Get all recurring events for a date range
    const getRecurringEventsInRange = useCallback((startDate: Date, endDate: Date) => {
        const recurringEvents: Event[] = [];

        patterns.forEach(pattern => {
            // Find a base event for this pattern
            const baseEvent = events.find(event =>
                event.recurrence?.id === pattern.id
            );

            if (baseEvent) {
                const generatedEvents = generateRecurringEvents(pattern.id, startDate, endDate, baseEvent);
                recurringEvents.push(...generatedEvents);
            }
        });

        return recurringEvents;
    }, [patterns, events]);

    // Get pattern for an event
    const getPatternForEvent = useCallback((eventId: string): RecurrencePattern | null => {
        const event = events.find(e => e.id === eventId);
        if (!event?.recurrence?.id) return null;

        return recurrenceService.getPattern(event.recurrence.id) || null;
    }, [events]);

    // Check if an event is recurring
    const isEventRecurring = useCallback((eventId: string): boolean => {
        const event = events.find(e => e.id === eventId);
        return !!event?.recurrence?.id;
    }, [events]);

    // Get next occurrence for a recurring event
    const getNextOccurrence = useCallback((eventId: string): Date | null => {
        const pattern = getPatternForEvent(eventId);
        if (!pattern) return null;

        const event = events.find(e => e.id === eventId);
        if (!event) return null;

        return recurrenceService.getNextOccurrenceAfter(pattern.id, event.startDate, event);
    }, [events, getPatternForEvent]);

    // Get all occurrences for a recurring event
    const getAllOccurrences = useCallback((eventId: string, startDate?: Date, endDate?: Date): Date[] => {
        const pattern = getPatternForEvent(eventId);
        if (!pattern) return [];

        const event = events.find(e => e.id === eventId);
        if (!event) return [];

        const start = startDate || new Date();
        const end = endDate || new Date();
        end.setMonth(end.getMonth() + 6); // Default to 6 months ahead

        return recurrenceService.getOccurrencesInRange(pattern.id, start, end, event);
    }, [events, getPatternForEvent]);

    // Format recurrence rule for display
    const formatRecurrenceRule = useCallback((rule: RecurrenceRule): string => {
        return getRecurrenceRuleString(rule);
    }, []);

    // Validate recurrence rule
    const validateRule = useCallback((rule: RecurrenceRule) => {
        return validateRecurrenceRule(rule);
    }, []);

    // Helper function to check if two dates are the same day
    const isSameDay = (date1: Date, date2: Date): boolean => {
        return date1.getFullYear() === date2.getFullYear() &&
            date1.getMonth() === date2.getMonth() &&
            date1.getDate() === date2.getDate();
    };

    // Get exceptions for a pattern
    const getExceptionsForPattern = useCallback((patternId: string): RecurrenceException[] => {
        return recurrenceService.getExceptions(patternId);
    }, []);

    // Remove an exception from a pattern
    const removeException = useCallback((patternId: string, exceptionId: string) => {
        const success = recurrenceService.removeException(patternId, exceptionId);
        if (success) {
            setPatterns(prev =>
                prev.map(pattern => {
                    if (pattern.id === patternId) {
                        return {
                            ...pattern,
                            exceptions: pattern.exceptions.filter(exc => exc.id !== exceptionId)
                        };
                    }
                    return pattern;
                })
            );
        }
        return success;
    }, []);

    // Edit a single occurrence vs entire series
    const editOccurrence = useCallback((
        eventId: string,
        updates: Partial<Event>,
        editSeries: boolean = false
    ) => {
        const event = events.find(e => e.id === eventId);
        if (!event) return;

        if (editSeries) {
            // Edit the entire series
            const pattern = getPatternForEvent(eventId);
            if (pattern) {
                // Update pattern rule if recurrence is modified
                if (updates.recurrence) {
                    updatePattern(pattern.id, { rule: updates.recurrence });
                }

                // Update all events in the series
                events
                    .filter(e => e.recurrence?.id === pattern.id)
                    .forEach(e => {
                        if (onEventUpdate) {
                            onEventUpdate(e.id, updates);
                        }
                    });
            }
        } else {
            // Edit only this occurrence
            const pattern = getPatternForEvent(eventId);
            if (pattern) {
                // Create an exception for this occurrence
                const updatedEvent = { ...event, ...updates };
                addException(pattern.id, event.startDate, updatedEvent, false);
            } else {
                // Just update the event if it's not recurring
                if (onEventUpdate) {
                    onEventUpdate(eventId, updates);
                }
            }
        }
    }, [events, getPatternForEvent, updatePattern, addException, onEventUpdate]);

    // Delete a single occurrence vs entire series
    const deleteOccurrence = useCallback((
        eventId: string,
        deleteSeries: boolean = false
    ) => {
        const event = events.find(e => e.id === eventId);
        if (!event) return;

        if (deleteSeries) {
            // Delete the entire series
            const pattern = getPatternForEvent(eventId);
            if (pattern) {
                deletePattern(pattern.id);
            } else {
                // Just delete the single event
                if (onEventDelete) {
                    onEventDelete(eventId);
                }
            }
        } else {
            // Delete only this occurrence
            const pattern = getPatternForEvent(eventId);
            if (pattern) {
                // Create an exception for this occurrence
                addException(pattern.id, event.startDate, undefined, true);
            } else {
                // Just delete the event if it's not recurring
                if (onEventDelete) {
                    onEventDelete(eventId);
                }
            }
        }
    }, [events, getPatternForEvent, deletePattern, addException, onEventDelete]);

    return {
        // State
        patterns,
        selectedPattern,
        isCreatingPattern,

        // Pattern management
        createPattern,
        updatePattern,
        deletePattern,
        setSelectedPattern,

        // Exception management
        addException,
        removeException,
        getExceptionsForPattern,

        // Event operations
        editOccurrence,
        deleteOccurrence,
        regenerateEventsForPattern,

        // Query functions
        getRecurringEventsInRange,
        getPatternForEvent,
        isEventRecurring,
        getNextOccurrence,
        getAllOccurrences,

        // Utility functions
        formatRecurrenceRule,
        validateRule,
        setIsCreatingPattern
    };
};